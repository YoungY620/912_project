# OS 2019 mid sectum
## 一、对错题
1. V  需要记录访问情况
2. V
3. V  共享内核地址空间即可
4. V
5. X  会由initproc回收
6. V  时钟中断是可屏蔽的
7. V  因为涉及到特权级
8. V
9. X  应当是代码和数据加起来510字节
10. X  eip-1是栈里面返回地址的位置，eip和eip-2就不是返回地址而是调用参数或者临时变量了
## 二、问答题
### 11）
不可
对于`read_ebp()`而言，如果使用非内联函数，则实际上进行了函数调用，因此读取到的ebp将变成`read_ebp()`函数的ebp，而非当前函数的ebp
对于`read_eip()`而言，如果使用内联函数，读取的`4(%%ebp)`实际上将是当前函数执行完之后的返回地址，而非当前函数的地址（`read_eip()`函数调用执行完之后的返回地址）

### 12）
|操作|返回值|free list|
|-|-|-|
|E=alloc 512KB|失败|[ (256,128), (640,384) ]|
|F=alloc 257KB|(640,257)|[ (256,128), (897,127) ]|
|G=alloc 64KB|(897,64))|[ (256,128), (961,63) ]|
|H=alloc 64KB|(256,64)|[ (320,64), (961,63) ]|
|free F|/|[ (320,64), (640,257), (961,63) ]|
I分配失败是因为内存中没有连续的300KB空闲内存。但总共剩余384KB。这种现象称之为外部碎片。
碎片紧凑和分区对换是解决外部碎片问题的两个办法。
碎片紧凑：通过移动分配给进程的内存分区，以合并外部碎片
分区对换：抢占并回收处于等待状态进程的分区，将其换出到磁盘以获取足够内存空间
### 13）又是人肉计算机，不想看了
### 14）
由于页目录最后一项为自映射，故页目录表位于连续虚拟空间的最后一页，即页目录表的起始虚拟地址为`0xfffff000`
一级页号为`la>>22 & 0x3FF`，二级页号为`la>>12 & 0x3FF`
要查找的pte为页表的第`la>>22 & 0x3FF`个页中的第`la>>12 & 0x3FF`项
也就是 页表起始地址 + la的高20位×4

```c
pte_t *get_pte(uintptr_t la) {
	return (pte_t*)( 0xffc00000[(la&0xfffff000)>>10] );
}
```
### 15）
1）全局置换算法会改变进程可用物理页帧数量，如缺页率置换算法
局部置换算法固定进程的可用物理页帧数量不变，如LRU置换算法
2）
时钟置换算法7次

| 序列 | c    | a    | d    | b    | e    | b    | a    | b    | c    | d    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | c1 *  | c1 *  | c1 *  | c1 *  | e1  | e1  | e1  | e1  | e1  | e0 |
|      | -    | a1   | a1   | a1   | a0 * | a0 * | a1 * | a1 * | a0 | d1 |
|      | -    | -    | d1   | d1   | d0   | d0   | d0   | d0   | c1 | c1 * |
|      | -    | -    | -    | b1   | b0   | b1   | b1   | b1   | b1 * | b0 |
| 缺页 | Y    | Y    | Y    | Y    | Y    |      |      |      | Y    | Y    |

LRU置换算法7次
| 序列 | c    | a    | d    | b    | e    | b    | a    | b    | c    | d    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | c    | c    | c    | c    | e    | e    | e    | e    | e    | d    |
|      |      | a    | a    | a    | a    | a    | a    | a    | a    | a    |
|      |      |      | d    | d    | d    | d    | d    | d    | c    | c    |
|      |      |      |      | b    | b    | b    | b    | b    | b    | b    |
| 缺页 | Y    | Y    | Y    | Y    | Y    |      |      |      | Y    | Y    |
belady是指进程可用物理页面增加的情况下，缺页率不降反升
OPT/LRU/恢复访问计数的LFU没有belady现象
FIFO/Clock/不恢复访问计数的LFU有belady现象
### 16）
1. `lcr3(next->cr3);`
2. `pushl 0(%eax)`
3. `load_esp0(next->kstack+KSTACKSIZE);`
4. 恢复next进程上下文中的edi寄存器内容，eax寄存器中存放着next->context的指针
### 17）
下表中行从左到右为时间顺序，同一列的内容先后顺序不定
|0|1|2|
|-|-|-|
||3->4||
可知可能的顺序包括：`01342 | 03142 | 03412`

